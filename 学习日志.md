# 操作系统小学期学习日志

## 第一天

第一天主要看了第0章、第1章和第2章部分。

1. 第0第一节主要讲了操作系统接口。
   操作系统通过接口向用户程序提供服务，而进程通过**系统调用**使用内核服务。系统调用会进入内核，让内核执行服务然后返回。所以进程总是在用户空间和内核空间之间交替运行。内核使用了 CPU 的硬件保护机制来保证用户进程只能访问自己的内存空间。内核拥有实现保护机制所需的硬件权限(hardware privileges)，而用户程序没有这些权限。当一个用户程序进行一次系统调用时，硬件会提升特权级并且开始执行一些内核中预定义的功能。内核提供的一系列系统调用就是用户程序可见的操作系统接口，xv6 内核提供了 Unix 传统系统调用的一部分，它们是：

| 系统调用                  | 描述                               |
| ------------------------- | ---------------------------------- |
| fork()                    | 创建进程                           |
| exit()                    | 结束当前进程                       |
| wait()                    | 等待子进程结束                     |
| kill(pid)                 | 结束 pid 所指进程                  |
| getpid()                  | 获得当前进程 pid                   |
| sleep(n)                  | 睡眠 n 秒                          |
| exec(filename, *argv)     | 加载并执行一个文件                 |
| sbrk(n)                   | 为进程内存空间增加 n 字节          |
| open(filename, flags)     | 打开文件，flags 指定读/写模式      |
| read(fd, buf, n)          | 从文件中读 n 个字节到 buf          |
| write(fd, buf, n)         | 从 buf 中写 n 个字节到文件         |
| close(fd)                 | 关闭打开的 fd                      |
| dup(fd)                   | 复制 fd                            |
| pipe( p)                  | 创建管道， 并把读和写的 fd 返回到p |
| chdir(dirname)            | 改变当前目录                       |
| mkdir(dirname)            | 创建新的目录                       |
| mknod(name, major, minor) | 创建设备文件                       |
| fstat(fd)                 | 返回文件信息                       |
| link(f1, f2)              | 给 f1 创建一个新名字(f2)           |
| unlink(filename)          | 删除文件                           |

​	shell 是一个普通的程序，它接受用户输入的命令并且执行它们，它也是传统 Unix 系统中最基本的用户界面。	shell 作为一个普通程序，而不是内核的一部分，充分说明了系统调用接口的强大。

2. 第0章第二节讲了进程和内存的一些关系，并举出fork和exec的例子。
   **fork**:一个进程可以通过系统调用 `fork` 来创建一个新的进程。`fork` 创建的新进程被称为**子进程**，子进程的内存内容同创建它的进程（父进程）一样。`fork` 函数在父进程、子进程中都返回（一次调用两次返回）。对于父进程它返回子进程的 pid，对于子进程它返回 0
   **exec**:系统调用 `exec` 将从某个*文件*（通常是可执行文件）里读取内存镜像，并将其替换到调用它的进程的内存空间。

3. 第0章第三节主要讲了I/O和文件描述符

   **文件描述符**是一个整数，它代表了一个进程可以读写的被内核管理的对象。每个进程都有一张表，而 xv6 内核就以文件描述符作为这张表的索引，所以每个进程都有一个从0开始的文件描述符空间。按照惯例，进程从文件描述符0读入（标准输入），从文件描述符1输出（标准输出），从文件描述符2输出错误（标准错误输出）。`fork` 会复制父进程的文件描述符和内存，所以子进程和父进程的文件描述符一模一样。`exec` 会替换调用它的进程的内存但是会保留它的文件描述符表。
   
4. 第0章第四节主要讲了管道
   管道是一个小的内核缓冲区，它以文件描述符对的形式提供给进程，一个用于写操作，一个用于读操作。从管道的一端写的数据可以从管道的另一端读取。管道提供了一种进程间交互的方式。管道和临时文件起码有三个关键的不同点。首先，管道会进行自我清扫，如果是 shell 重定向的话，我们必须要在任务完成后删除 `/tmp/xyz`。第二，管道可以传输任意长度的数据。第三，管道允许同步：两个进程可以使用一对管道来进行二者之间的信息传递，每一个读操作都阻塞调用进程，直到另一个进程用 `write` 完成数据的发送。

5. 第0章第五节主要讲了文件系统。
   xv6 文件系统提供文件和目录，文件就是一个简单的字节数组，而目录包含指向文件和其他目录的引用。xv6 把目录实现为一种特殊的文件。目录是一棵树，它的根节点是一个特殊的目录 `root`。`/a/b/c` 指向一个在目录 `b` 中的文件 `c`，而 b 本身又是在目录 `a` 中的，`a` 又是处在 `root` 目录下的。系统调用 `unlink` 从文件系统移除一个文件名。一个文件的 inode 和磁盘空间只有当它的链接数变为 0 的时候才会被清空，也就是没有一个文件再指向它。

6. 第2章主要讲了第一个进程和一些地址空间。
   xv6使用页表来为进程提供独有的地址空间。页表将*虚拟地址*（x86 指令所使用的地址）翻译（或说“映射”）为*物理地址*（处理器芯片向主存发送的地址）。xv6 使用结构体 `struct proc` (2103) 来维护一个进程的众多状态。一个进程最为重要的状态是进程的页表，内核栈，当前运行状态。
   每个进程都有一个**运行线程**（或简称为*线程*）来执行进程的指令。线程可以被暂时挂起，稍后再恢复运行。系统在进程之间切换实际上就是挂起当前运行的线程，恢复另一个进程的线程。线程的大多数状态（局部变量和函数调用的返回地址）都保存在线程的栈上。
   在一开始的时候，还没有进入保护模式，没有分页，所以虚拟地址此时是**直接**映射到物理地址上的。
   第一个进程需要为其内核线程分配内核栈。`allocproc`在分配内核栈扮演者重要的角色。它以巧妙的方式，使其既能在创建第一个进程时被使用，又能在 `fork` 操作时被使用。

   ```c
       //PAGEBREAK: 32
       // Look in the process table for an UNUSED proc.
       // If found, change state to EMBRYO and initialize
       // state required to run in the kernel.
       // Otherwise return 0.
       static struct proc*
       allocproc(void)
       {
         struct proc *p;
         char *sp;

         acquire(&ptable.lock);
         for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
           if(p->state == UNUSED)
             goto found;
         release(&ptable.lock);
         return 0;

       found:
         p->state = EMBRYO;
         p->pid = nextpid++;
         release(&ptable.lock);

         // Allocate kernel stack.
         if((p->kstack = kalloc()) == 0){
           p->state = UNUSED;
           return 0;
         }
         // #define KSTACKSIZE 4096 
         //这里将sp移动到栈底
         sp = p->kstack + KSTACKSIZE;

         // Leave room for trap frame.
         // 将sp向下移，为trapframe留够空间
         sp -= sizeof *p->tf;
         p->tf = (struct trapframe*)sp;

         // Set up new context to start executing at forkret,
         // which returns to trapret.
         // 放置traptet
         sp -= 4;
         *(uint*)sp = (uint)trapret;
         // 放新进程的context并初始化
         sp -= sizeof *p->context;
         p->context = (struct context*)sp;
         memset(p->context, 0, sizeof *p->context);
         // 下一个程序就是forkret
         p->context->eip = (uint)forkret;

         return p;
        }
   
   ```

   

它所构建出的栈示意图

![figure1-3](./img/f1-3.png)

   

   


7. 第1章第五节主要讲了第一个系统调用exec
   `initcode.S`（7708）刚开始会将 `$argv，$init，$0` 三个值推入栈中，接下来把 `%eax` 设置为 `SYS_exec` 然后执行 `int T_SYSCALL`：这样做是告诉内核运行 `exec` 这个系统调用。如果运行正常的话，`exec` 不会返回：它会运行名为 `$init` 的程序，`$init` 是一个以空字符结尾的字符串，即 `/init`（7721-7723）。如果 `exec` 失败并且返回了，`initcode` 会循环调用一个不会返回的系统调用 `exit` 。

   系统调用 `exec` 的参数是 `$init、$argv`。最后的`0`让这个手动构建的系统调用看起来就像普通的系统调用一样，我们会在第3章详细讨论这个问题。和之前的代码一样，xv6 努力避免为第一个进程的运行单独写一段代码，而是尽量使用通用于普通操作的代码。

```c
   // Initial process execs /init.

   #include "syscall.h"
   #include "traps.h"


   // exec(init, argv)
   .globl start
   start:
     pushl $argv
     pushl $init
     pushl $0  // where caller pc would be
     movl $SYS_exec, %eax
     int $T_SYSCALL

   // for(;;) exit();
   exit:
     movl $SYS_exit, %eax
     int $T_SYSCALL
     jmp exit

   // char init[] = "/init\0";
   init:
     .string "/init\0"

   // char *argv[] = { init, 0 };
   .p2align 2
   argv:
     .long init
     .long 0

```

   

## 第二天

1. 第三章主要讲了陷入、中断和驱动程序。

   术语`exception`指产生中断的非法程序操作，例如除以0，尝试访问 PTE 不存在的内存等等。术语`interrupt`指硬件产生的希望引起操作系统注意的信号，例如时钟芯片可能每100毫秒产生一个中断，以此来实现分时。

   **x86的保护机制**

   x86 有四个特权级，从 0（特权最高）编号到 3（特权最低）。在实际使用中，大多数的操作系统都使用两个特权级，0 和 3，他们被称为内核模式和用户模式。当前执行指令的特权级存在于 %cs 寄存器中的 CPL 域中。
   一个程序要在 x86 上进行一个**系统调用**，它需要调用 **int n** 指令。

   int 指令进行下面一些步骤：

   - 从 IDT 中获得第 n 个描述符，n 就是 int 的参数。
   - 检查 %cs 的域 CPL <= DPL，DPL 是描述符中记录的特权级。
   - 如果目标段选择符的 PL < CPL，就在 CPU 内部的寄存器中保存 %esp 和 %ss 的值。
   - 从一个任务段描述符中加载 %ss 和 %esp。
   - 将 %ss 压栈。
   - 将 %esp 压栈。
   - 将 %eflags 压栈。
   - 将 %cs 压栈。
   - 将 %eip 压栈。
   - 清除 %eflags 的一些位。
   - 设置 %cs 和 %eip 为描述符中的值。

   ![figure3-1](./img/f3-1.png)

   图 3-1 展示了一个 int 指令之后的栈的情况，注意这是发生了特权级转换（即描述符中的特权级比 CPL 中的特权级低的时候）栈的情况。如果这条指令没有导致特权级转换，x86 就不会保存 %ss 和%esp。

   **汇编陷入处理程序**

   `Tvinit` (3067) 在 `main` 中被调用，它设置了 `idt` 表中的 256 个表项。中断 i 被位于 `vectors[i]` 的代码处理。每一个中断处理程序的入口点都是不同的，因为 x86 并未把中断号传递给中断处理程序，使用 `256` 个不同的处理程序是区分这 256 种情况的唯一办法。

   ```c
   // Interrupt descriptor table (shared by all CPUs).
   struct gatedesc idt[256];
   extern uint vectors[];  // in vectors.S: array of 256 entry pointers
   struct spinlock tickslock;
   uint ticks;
   
   void
   tvinit(void)
   {
     int i;
   
     for(i = 0; i < 256; i++)
       SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
     SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
     
     initlock(&tickslock, "time");
   }
   ```

   `Tvinit` 处理 `T_SYSCALL`，用户系统会调用 trap，特别地：它通过传递第二个参数值为 1 来指定这是一个陷阱门。陷阱门不会清除 FL 位，这使得在处理系统调用的时候也接受其他中断。

   当内陷发生时，处理器会做下面一些事。如果处理器在**用户模式**下运行，它会从任务段描述符中加载 %esp 和 %ss，把老的 %ss 和 %esp 压入新的栈中。如果处理器在内核模式下运行，上面的事件就不会发生。处理器接下来会把 %eflags，%cs，%eip 压栈。对于某些内陷来说，处理器会压入一个错误字。而后，处理器从相应 IDT 表项中加载新的 %eip 和 %cs。

   xv6 使用一个 **perl** 脚本（2950）来产生 IDT 表项指向的中断处理函数入口点。每一个入口都会压入一个错误码（如果 CPU 没有压入的话），压入中断号，然后跳转到 `alltraps`。

   `Alltraps`（3004）继续保存处理器的寄存器：它压入 %ds, %es, %fs, %gs, 以及通用寄存器（3005-3010)。这么做使得内核栈上压入一个 `trapframe`（中断帧） 结构体，这个结构体包含了中断发生时处理器的寄存器状态（参见图3-2）。处理器负责压入 %ss，%esp，%eflags，%cs 和 %eip。处理器或者中断入口会压入一个错误码，而`alltraps`负责压入剩余的。中断帧包含了所有处理器从当前进程的内核态恢复到用户态需要的信息，所以处理器可以恰如中断开始时那样继续执行。回顾一下第一章，`userinit`通过手动建立中断帧来达到这个目标（参见图1-3）。

   ```perl
   #!/usr/bin/perl -w
   
   # Generate vectors.S, the trap/interrupt entry points.
   # There has to be one entry point per interrupt number
   # since otherwise there's no way for trap() to discover
   # the interrupt number.
   
   print "# generated by vectors.pl - do not edit\n";
   print "# handlers\n";
   print ".globl alltraps\n";
   for(my $i = 0; $i < 256; $i++){
       print ".globl vector$i\n";
       print "vector$i:\n";
       if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
           print "  pushl \$0\n";
       }
       print "  pushl \$$i\n";
       print "  jmp alltraps\n";
   }
   
   print "\n# vector table\n";
   print ".data\n";
   print ".globl vectors\n";
   print "vectors:\n";
   for(my $i = 0; $i < 256; $i++){
       print "  .long vector$i\n";
   }
   
   # sample output:
   #   # handlers
   #   .globl alltraps
   #   .globl vector0
   #   vector0:
   #     pushl $0
   #     pushl $0
   #     jmp alltraps
   #   ...
   #   
   #   # vector table
   #   .data
   #   .globl vectors
   #   vectors:
   #     .long vector0
   #     .long vector1
   #     .long vector2
   #   ...
   ```

   ![](./img/f3-2.png)

   

   **C 中断处理程序**

   `trap`（3101）查看硬件中断号 `tf->trapno` 来判断自己为什么被调用以及应该做些什么。如果中断是 `T_SYSCALL`，`trap` 调用系统调用处理程序 `syscall`。

   当检查完是否是系统调用，`trap` 会继续检查是否是硬件中断（我们会在下面讨论）。中断可能来自硬件设备的正常中断，也可能来自异常的、未预料到的硬件中断。

   如果中断不是一个系统调用也不是一个硬件主动引发的中断，`trap` 就认为它是一个发生中断前的一段代码中的错误行为导致的中断（如除零错误）。如果产生中断的代码来自用户程序，xv6 就打印错误细节并且设置 `cp->killed` 使之待会被清除掉。

   **系统调用**

   对于系统调用，`trap` 调用 `syscall`（3375）。`syscall` 从中断帧中读出系统调用号，中断帧也包括被保存的 %eax，以及到系统调用函数表的索引。对第一个系统调用而言，%eax 保存的是 SYS_exec（3207），并且 `syscall` 会调用第 `SYS_exec` 个系统调用函数表的表项，相应地也就调用了 `sys_exec`。

   `syscall` 在 %eax 保存系统调用函数的返回值。当 `trap` 返回用户空间时，它会从 `cp->tf` 中加载其值到寄存器中。因此，当 `exec` 返回时，它会返回系统调用处理函数返回的返回值（3381）。系统调用按照惯例会在发生错误的时候返回一个小于 0 的数，成功执行时返回正数。如果系统调用号是非法的，syscall 会打印错误并且返回 -1。

   ```c
   //PAGEBREAK: 41
   void
   trap(struct trapframe *tf)
   {
     if(tf->trapno == T_SYSCALL){
       if(proc->killed)
         exit();
       proc->tf = tf;
       syscall();
       if(proc->killed)
         exit();
       return;
     }
   
     switch(tf->trapno){
     case T_IRQ0 + IRQ_TIMER:
       if(cpu->id == 0){
         acquire(&tickslock);
         ticks++;
         wakeup(&ticks);
         release(&tickslock);
       }
       lapiceoi();
       break;
     case T_IRQ0 + IRQ_IDE:
       ideintr();
       lapiceoi();
       break;
     case T_IRQ0 + IRQ_IDE+1:
       // Bochs generates spurious IDE1 interrupts.
       break;
     case T_IRQ0 + IRQ_KBD:
       kbdintr();
       lapiceoi();
       break;
     case T_IRQ0 + IRQ_COM1:
       uartintr();
       lapiceoi();
       break;
     case T_IRQ0 + 7:
     case T_IRQ0 + IRQ_SPURIOUS:
       cprintf("cpu%d: spurious interrupt at %x:%x\n",
               cpu->id, tf->cs, tf->eip);
       lapiceoi();
       break;
      
     //PAGEBREAK: 13
     default:
       if(proc == 0 || (tf->cs&3) == 0){
         // In kernel, it must be our mistake.
         cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
                 tf->trapno, cpu->id, tf->eip, rcr2());
         panic("trap");
       }
       // In user space, assume process misbehaved.
       cprintf("pid %d %s: trap %d err %d on cpu %d "
               "eip 0x%x addr 0x%x--kill proc\n",
               proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip, 
               rcr2());
       proc->killed = 1;
     }
   
     // Force process exit if it has been killed and is in user space.
     // (If it is still executing in the kernel, let it keep running 
     // until it gets to the regular system call return.)
     if(proc && proc->killed && (tf->cs&3) == DPL_USER)
       exit();
   
     // Force process to give up CPU on clock tick.
     // If interrupts were on while locks held, would need to check nlock.
     if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
       yield();
   
     // Check if the process has been killed since we yielded
     if(proc && proc->killed && (tf->cs&3) == DPL_USER)
       exit();
   }
   
   ```

   ```c
   extern int sys_chdir(void);
   extern int sys_close(void);
   extern int sys_dup(void);
   extern int sys_exec(void);
   extern int sys_exit(void);
   extern int sys_fork(void);
   extern int sys_fstat(void);
   extern int sys_getpid(void);
   extern int sys_kill(void);
   extern int sys_link(void);
   extern int sys_mkdir(void);
   extern int sys_mknod(void);
   extern int sys_open(void);
   extern int sys_pipe(void);
   extern int sys_read(void);
   extern int sys_sbrk(void);
   extern int sys_sleep(void);
   extern int sys_unlink(void);
   extern int sys_wait(void);
   extern int sys_write(void);
   extern int sys_uptime(void);
   
   static int (*syscalls[])(void) = {
   [SYS_fork]    sys_fork,
   [SYS_exit]    sys_exit,
   [SYS_wait]    sys_wait,
   [SYS_pipe]    sys_pipe,
   [SYS_read]    sys_read,
   [SYS_kill]    sys_kill,
   [SYS_exec]    sys_exec,
   [SYS_fstat]   sys_fstat,
   [SYS_chdir]   sys_chdir,
   [SYS_dup]     sys_dup,
   [SYS_getpid]  sys_getpid,
   [SYS_sbrk]    sys_sbrk,
   [SYS_sleep]   sys_sleep,
   [SYS_uptime]  sys_uptime,
   [SYS_open]    sys_open,
   [SYS_write]   sys_write,
   [SYS_mknod]   sys_mknod,
   [SYS_unlink]  sys_unlink,
   [SYS_link]    sys_link,
   [SYS_mkdir]   sys_mkdir,
   [SYS_close]   sys_close,
   };
   
   void
   syscall(void)
   {
     int num;
   
     num = proc->tf->eax;
     if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
       proc->tf->eax = syscalls[num]();
     } else {
       cprintf("%d %s: unknown sys call %d\n",
               proc->pid, proc->name, num);
       proc->tf->eax = -1;
     }
   }
   
   ```

   **中断**

   像 x86 处理器一样，PC 主板也在进步，并且提供中断的方式也在进步。早期的主板有一个简单的可编程中断控制器（被称作 PIC），你可以在 picirq.c 中找到管理它的代码。随着多核处理器主板的出现，需要一种新的处理中断的方式，因为每一颗 CPU 都需要一个中断控制器来处理发送给它的中断，而且也得有一个方法来分发中断。这一方式包括两个部分：第一个部分是在 **I/O 系统中**的（IO APIC，ioapic.c），另一部分是**关联在每一个处理器上**的（局部 APIC，lapic.c）。xv6 是为搭载多核处理器的主板设计的，每一个处理器都需要编程接受中断。为了支持多于八个硬件，PIC 可以进行级联，典型的主板至少有两集级联。使用 `inb` 和 `outb` 指令，xv6 配置主 PIC 产生 IRQ 0 到 7，从 PIC 产生 IRQ 8 到 16。
   处理器可以通过设置 `eflags` 寄存器中的 `IF` 位来控制自己是否想要收到中断。指令 `cli` 通过清除 `IF` 位来屏蔽中断，而 `sti` 又打开一个中断。

2. 第4章主要讲了锁和一些和锁相关的问题
   
   xv6 采用了386硬件上的一条特殊指令 `xchg`（0569）。在一个原子操作里，`xchg` 交换了内存中的一个字和一个寄存器的值。函数 `acquire`（1474）在循环中反复使用 `xchg`；每一次都读取 `lk->locked` 然后设置为1（1483）。如果锁已经被持有了，`lk->locked` 就已经为1了，故 `xchg` 会返回1然后继续循环。如果 `xchg` 返回0，但是 `acquire` 已经成功获得了锁，即 `locked` 已经从0变为了1，这时循环可以停止了。一旦锁被获得了，`acquire` 会记录获得锁的 CPU 和栈信息，以便调试。当某个进程获得了锁却没有释放时，这些信息可以帮我们找到问题所在。当然这些信息也被锁保护着，只有在持有锁时才能修改。
   
   函数 `release`（1502）则做了相反的事：清除调试信息并释放锁。
   
   ```c
   // Acquire the lock.
   // Loops (spins) until the lock is acquired.
   // Holding a lock for a long time may cause
   // other CPUs to waste time spinning to acquire it.
   void
   acquire(struct spinlock *lk)
   {
     pushcli(); // disable interrupts to avoid deadlock.
     if(holding(lk))
       panic("acquire");
   
     // The xchg is atomic.
     // It also serializes, so that reads after acquire are not
     // reordered before it. 
     while(xchg(&lk->locked, 1) != 0)
       ;
   
     // Record info about lock acquisition for debugging.
     lk->cpu = cpu;
     getcallerpcs(&lk, lk->pcs);
   }
   // Release the lock.
   void
   release(struct spinlock *lk)
   {
     if(!holding(lk))
       panic("release");
   
     lk->pcs[0] = 0;
     lk->cpu = 0;
   
     // The xchg serializes, so that reads before release are 
     // not reordered after it.  The 1996 PentiumPro manual (Volume 3,
     // 7.2) says reads can be carried out speculatively and in
     // any order, which implies we need to serialize here.
     // But the 2007 Intel 64 Architecture Memory Ordering White
     // Paper says that Intel 64 and IA-32 will not move a load
     // after a store. So lock->locked = 0 would work here.
     // The xchg being asm volatile ensures gcc emits it after
     // the above assignments (and after the critical section).
     xchg(&lk->locked, 0);
   
     popcli();
   }
   ```
   
3. 第5章主要讲调度。文中涉及上下文切换、睡眠、唤醒和一些函数wait、exit和kill。
   **上下文切换**

   xv6 在低层次中实现了两种上下文切换：从**进程的内核线程**切换到当前 **CPU 的调度器线程**，从调度器线程到进程的内核线程。

   ![](./img/f5-1.png)

   线程的切换涉及到了保存旧线程的 CPU 寄存器，恢复新线程之前保存的寄存器；其中 `%esp` 和 `%eip` 的变换意味着 CPU 会切换运行栈与运行代码。

   `swtch` 并不了解线程，它只是简单地保存和恢复寄存器集合，即*上下文*。

   ```c
   # Context switch
   #
   #   void swtch(struct context **old, struct context *new);
   # 
   # Save current register context in old
   # and then load register context from new.
   
   .globl swtch
   swtch:
     movl 4(%esp), %eax
     movl 8(%esp), %edx
   
     # Save old callee-save registers
     pushl %ebp
     pushl %ebx
     pushl %esi
     pushl %edi
   
     # Switch stacks
     movl %esp, (%eax)
     movl %edx, %esp
   
     # Load new callee-save registers
     popl %edi
     popl %esi
     popl %ebx
     popl %ebp
     ret
   
   ```

   **调度**

   ```c
   //PAGEBREAK: 42
   // Per-CPU process scheduler.
   // Each CPU calls scheduler() after setting itself up.
   // Scheduler never returns.  It loops, doing:
   //  - choose a process to run
   //  - swtch to start running that process
   //  - eventually that process transfers control
   //      via swtch back to the scheduler.
   void
   scheduler(void)
   {
     struct proc *p;
   
     for(;;){
       // Enable interrupts on this processor.
       sti();
   
       // Loop over process table looking for process to run.
       acquire(&ptable.lock);
       for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
         if(p->state != RUNNABLE)
           continue;
   
         // Switch to chosen process.  It is the process's job
         // to release ptable.lock and then reacquire it
         // before jumping back to us.
         proc = p;
         switchuvm(p);
         p->state = RUNNING;
         swtch(&cpu->scheduler, proc->context);
         switchkvm();
   
         // Process is done running for now.
         // It should have changed its p->state before coming back.
         proc = 0;
       }
       release(&ptable.lock);
   
     }
   }
   ```

   上一节中我们查看了 `swtch` 的底层细节；现在让我们将 `swtch` 看做一个既有的功能，来研究从进程到调度器然后再回到进程的切换过程中的一些约定。进程想要让出 CPU 必须要获得进程表的锁 `ptable.lock`，并释放其拥有的其他锁，修改自己的状态（`proc->state`），然后调用 `sched`。`yield`（2522）和 `sleep exit` 都遵循了这个约定，我们稍后将会详细研究。`sched` 检查了两次状态（2507-2512），这里的状态表明由于进程此时持有锁，所以 CPU 应该是在中断关闭的情况下运行的。最后，`sched` 调用 `swtch` 把当前上下文保存在 `proc->context` 中然后切换到调度器上下文即 `cpu->scheduler` 中。`swtch` 返回到调度器栈中，就像是调度器调用的 `swtch` 返回了一样（2478）。调度器继续其 `for` 循环，找到一个进程来运行，切换到该进程，然后继续轮转。

   `scheduler`（2458）运行了一个普通的循环：找到一个进程来运行，运行直到其停止，然后继续循环。`scheduler` 大部分时间里都持有 `ptable.lock`，但在每次外层循环中都要释放该锁（并显式地允许中断）。当 CPU 闲置（找不到 `RUNNABLE` 的进程）时这样做十分有必要。如果一个闲置的调度器一直持有锁，那么其他 CPU 就不可能执行上下文切换或任何和进程相关的系统调用了，也就更不可能将某个进程标记为 `RUNNABLE` 然后让闲置的调度器能够跳出循环了。而之所以周期性地允许中断，则是因为可能进程都在等待 I/O，从而找不到一个 `RUNNABLE` 的进程（例如 shell）；如果调度器一直不允许中断，I/O 就永远无法到达了。

   `scheduler` 不断循环寻找可运行，即 `p->state == RUNNABLE` 的进程。一旦它找到了这样的进程，就将 per-cpu 的当前进程变量 `proc` 设为该进程，用 `switchuvm` 切换到该进程的页表，标记该进程为 `RUNNING`，然后调用 `swtch` 切换到该进程中运行（2472-2478）。

   **睡眠和唤醒**

   ```c
   // Atomically release lock and sleep on chan.
   // Reacquires lock when awakened.
   void
   sleep(void *chan, struct spinlock *lk)
   {
     if(proc == 0)
       panic("sleep");
   
     if(lk == 0)
       panic("sleep without lk");
   
     // Must acquire ptable.lock in order to
     // change p->state and then call sched.
     // Once we hold ptable.lock, we can be
     // guaranteed that we won't miss any wakeup
     // (wakeup runs with ptable.lock locked),
     // so it's okay to release lk.
     if(lk != &ptable.lock){  //DOC: sleeplock0
       acquire(&ptable.lock);  //DOC: sleeplock1
       release(lk);
     }
   
     // Go to sleep.
     proc->chan = chan;
     proc->state = SLEEPING;
     sched();
   
     // Tidy up.
     proc->chan = 0;
   
     // Reacquire original lock.
     if(lk != &ptable.lock){  //DOC: sleeplock2
       release(&ptable.lock);
       acquire(lk);
     }
   }
   
   //PAGEBREAK!
   // Wake up all processes sleeping on chan.
   // The ptable lock must be held.
   static void
   wakeup1(void *chan)
   {
     struct proc *p;
   
     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
       if(p->state == SLEEPING && p->chan == chan)
         p->state = RUNNABLE;
   }
   
   // Wake up all processes sleeping on chan.
   void
   wakeup(void *chan)
   {
     acquire(&ptable.lock);
     wakeup1(chan);
     release(&ptable.lock);
   }
   ```

   **代码：`wait`, `exit`, `kill`**

   wait

   ```c
   // Wait for a child process to exit and return its pid.
   // Return -1 if this process has no children.
   int
   wait(void)
   {
     struct proc *p;
     int havekids, pid;
   
     acquire(&ptable.lock);
     for(;;){
       // Scan through table looking for zombie children.
       havekids = 0;
       for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
         if(p->parent != proc)
           continue;
         havekids = 1;
         if(p->state == ZOMBIE){
           // Found one.
           pid = p->pid;
           kfree(p->kstack);
           p->kstack = 0;
           freevm(p->pgdir);
           p->state = UNUSED;
           p->pid = 0;
           p->parent = 0;
           p->name[0] = 0;
           p->killed = 0;
           release(&ptable.lock);
           return pid;
         }
       }
   
       // No point waiting if we don't have any children.
       if(!havekids || proc->killed){
         release(&ptable.lock);
         return -1;
       }
   
       // Wait for children to exit.  (See wakeup1 call in proc_exit.)
       sleep(proc, &ptable.lock);  //DOC: wait-sleep
     }
   }
   ```

   `wait` 首先要求获得 `ptable.lock`，然后查看进程表中是否有子进程，如果找到了子进程，并且没有一个子进程已经退出，那么就调用 `sleep` 等待其中一个子进程退出（2439），然后不断循环。注意，这里 `sleep` 中释放的锁是 `ptable.lock`，也就是我们之前提到过的特殊情况。(lk==ptable.lock)

   exit

   ```c
   // Exit the current process.  Does not return.
   // An exited process remains in the zombie state
   // until its parent calls wait() to find out it exited.
   void
   exit(void)
   {
     struct proc *p;
     int fd;
   
     if(proc == initproc)
       panic("init exiting");
   
     // Close all open files.
     for(fd = 0; fd < NOFILE; fd++){
       if(proc->ofile[fd]){
         fileclose(proc->ofile[fd]);
         proc->ofile[fd] = 0;
       }
     }
   
     iput(proc->cwd);
     proc->cwd = 0;
   
     acquire(&ptable.lock);
   
     // Parent might be sleeping in wait().
     wakeup1(proc->parent);
   
     // Pass abandoned children to init.
     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
       if(p->parent == proc){
         p->parent = initproc;
         if(p->state == ZOMBIE)
           wakeup1(initproc);
       }
     }
   
     // Jump into the scheduler, never to return.
     proc->state = ZOMBIE;
     sched();
     panic("zombie exit");
   }
   ```

   `exit` 首先要求获得 `ptable.lock` 然后唤醒当前进程的父进程（2376）。这一步似乎为时过早，但由于 `exit` 这时还没有把当前进程标记为 `ZOMBIE`，所以这样并不会出错：即使父进程已经是 `RUNNABLE` 的了，但在 `exit` 调用 `sched` 以释放 `ptable.lock` 之前，`wait` 是无法运行其中的循环的。所以说只有在子进程被标记为 `ZOMBIE`(2388)之后， `wait` 才可能找到要退出的子进程。在退出并重新调度之前，`exit` 会把所有子进程交给 `initproc`（2378-2385）。最后，`exit` 调用 `sched` 来让出 CPU。

   退出进程的父进程本来是通过调用 `wait`（2439）处于睡眠状态中，不过现在它就可以被调度器调度了。对 `sleep` 的调用返回时仍持有 `ptable.lock` ；`wait` 接着会重新查看进程表并找到 `state == ZOMBIE`（2382）的已退出子进程。它会记录该子进程的 `pid` 然后清理其 `struct proc`，释放相关的内存空间（2418-2426）。

   子进程在 `exit` 时已经做好了大部分的清理工作，但父进程一定要为其释放 `p->kstack` 和 `p->pgdir`；当子进程运行 `exit` 时，它正在利用 `p->kstack` 分配到的栈以及 `p->pgdir` 对应的页表。所以这两者只能在子进程结束运行后，通过调用 `sched` 中的 `swtch` 被清理。这就是为什么调度器要运行在自己单独的栈上，而不能运行在调用 `sched` 的线程的栈上。

   kill 

   ```c
   // Kill the process with the given pid.
   // Process won't exit until it returns
   // to user space (see trap in trap.c).
   int
   kill(int pid)
   {
     struct proc *p;
   
     acquire(&ptable.lock);
     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
       if(p->pid == pid){
         p->killed = 1;
         // Wake process from sleep if necessary.
         if(p->state == SLEEPING)
           p->state = RUNNABLE;
         release(&ptable.lock);
         return 0;
       }
     }
     release(&ptable.lock);
     return -1;
   }
   ```

   `exit` 让一个应用程序可以自我终结；`kill`（2625）则让一个应用程序可以终结其他进程。在实现 `kill` 时有两个困难：1）被终结的进程可能正在另一个 CPU 上运行，所以它必须在被终结之前把 CPU 让给调度器；2）被终结的进程可能正在 `sleep` 中，并持有内核资源。`kill` 很轻松地解决了这两个难题：它在进程表中设置被终结的进程的 `p->killed`，如果这个进程在睡眠中则唤醒之。如果被终结的进程正在另一个处理器上运行，它总会通过系统调用或者中断（例如时钟中断）进入内核。当它离开内核时，`trap` 会检查它的 `p->killed`，如果被设置了，该进程就会调用 `exit`，终结自己。











