## 调度算法

参考文章：

1. 博客：

[几种进程调度算法总结](https://blog.csdn.net/ttyue_123/article/details/52166497)

[Inside the Linux 2.6 Completely Fair Scheduler](https://developer.ibm.com/tutorials/l-completely-fair-scheduler/)

[WIKI](https://en.wikipedia.org/wiki/Completely_Fair_Scheduler#Algorithm)

[github](https://github.com/shrivinayak/CFS-Scheduler)

2. 论文或书籍：

《three easy pieces》第九章  [Lottery Scheduling](http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched-lottery.pdf)和[Multi-CPU Scheduling](http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched-multi.pdf)

《[Understanding the Linux 2.6. 8.1 CPU scheduler](https://www-inst.eecs.berkeley.edu/~cs194-24/sp13/hand-outs/linuxKernelUnderstandingQueudet.pdf)》



CFS(完全公平调度算法)

1. vruntime，一个积累值，每次CFS会选择最小的vruntime运行。

2. sched_latency，CFS使用此值来确定在考虑切换之前一个进程应运行多长时间,需要除以进程数 （48 milliseconds）

3. min_granularity 最少花费时间（6 milliseconds) ，保证效率，否则会在频繁的上下文切换中耗费时间。

4. 权值

```c
 static const int prio_to_weight[40] = {
 / * -20 * / 88761, 71755, 56483, 46273, 36291,
 / * -15 * / 29154, 23254, 18705, 14949, 11916,
 / * -10 * / 9548, 7620, 6100, 4904, 3906,
 / * -5 * / 3121, 2501, 1991, 1586, 1277,
 / * 0 * / 1024, 820, 655, 526, 423,
 / * 5 * / 335, 272, 215, 172, 137,
 / * 10 * / 110, 87, 70, 56, 45,
 / * 15 * / 36, 29, 23, 18, 15,
 };
```

![](./img/vruntiem1.png)

4. 为了保证效率，process(only running or runnable) 存在 red-black tree里

   > A
   > red-black tree is one of many types of balanced trees; in contrast to a simple binary tree (which can degenerate to list-like performance under worst-case insertion patterns), balanced trees do a little extra work to maintain low depths, and thus ensure that operations are logarithmic
   > (and not linear) in time.

5. 需要正确处理sleep过久的进程



调用链：

main()->pinit()->

代码详解：

```c
//proc.c
//Red-Black Tree data structure
struct redblackTree {
  // 节点数量
  int count;
  // 权重
  int rbTreeWeight;
  // 根节点
  struct proc *root;
  // 最小虚拟运行时间
  struct proc *min_vRuntime;
  
  struct spinlock lock;
  
  int period;
}rbTree; 
```

初始化运行队列

```c
// proc.c
static struct redblackTree *runnableTasks = &rbTree;
// main.c
void
pinit(void)
{
  initlock(&ptable.lock, "ptable");
  // 初始化红黑树
  rbinit(runnableTasks, "runnableTasks");
}
// proc.c
/*
  rbinit(struct redblackTree*, char)
  parameters: pointer that contains the address of the red-black tree and a string containing the name of the lock
  returns: none
  This function will initialize the red black tree data structure.
*/
void
rbinit(struct redblackTree *tree, char *lockName)
{
  initlock(&tree->lock, lockName);
  tree->count = 0;
  tree->root = 0;
  tree->rbTreeWeight = 0;
  tree->min_vRuntime = 0;

  //Initially set time slice factor for all processes
  tree->period = latency;
}
```



```c
static struct proc*
allocproc(void)
{
	.....
    //Set up fields of the process that are used by the CFS, which include fields to implement red-black tree
   p->virtualRuntime = 0;
   p->currentRuntime = 0;
   p->maximumExecutiontime = 0;
   p->niceValue = 0;

   p->left = 0;
   p->right = 0;
   p->parentP = 0;
}
```



